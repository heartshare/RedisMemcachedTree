# RedisMemcachedTree
Redis/Redisson, memcached缓存

<pre>
缓存
	客户端缓存
	    1）页面缓存（页面元素）
	    2）浏览器缓存（图片等）
	网络中的缓存
	    1）web代理缓存（如nginx）
	    2）边缘缓存（如CDN技术）
	服务端缓存
	    1）数据库缓存
	    2）平台级缓存（如Ehcache）
	    3）应用级缓存（如redis, memcached）
</pre>

<pre>
分布式系统理论
    1）一致性（C）
    2）可用性（A）
    3）分区容忍性（P）
</pre>

<pre>
Redis
1) redis实现消息队列功能
2）redis数据结构
3）redis数据安全与性能保障
    1）数据持久化
       快照、AOF 重写压缩AOF
    2）复制
    3）处理系统故障
    5）redis故障
    6）性能
5）降低内存占用
   1）短结构
      压缩
   2）分片结构
6）redis的lua脚本编程   
</pre>

<pre>
1) memcached数据结构
</pre>

<pre>
Evcache
	Evcache是一个非常优秀的缓存服务，能够提供低延迟，高可靠性的解决方案，基于memcached的内存存储，
	Evcache典型的适合对强一致性没有必须要求的场合
	   1）大流量
	   2）健壮的key-value编程接口，每秒处理3千万请求，存储数十亿个对象，跨数千台memcached服务器
    Evcache是典型的客户端/服务器架构，服务器包括一个memcached进程，还包括一个Prana的java进程用于与发现服务通信并托管本地管理，以及监控服务健康状态和统计状态的各种应用，并将统计信息发送给Netflix平台的统计服务面向微服务的java应用提供了一个集成应用程序到微服务生态系统的HTTP接口，主要功能包括
		1）注册到发现系统
		2）其他服务的发现
		3）健康检查服务
		5）HTTP API和负载均衡要求
		6）动态属性加载
</pre>


redis

![](https://i.imgur.com/sbIs3eL.jpg)

![](https://i.imgur.com/kbZHig4.jpg)

<pre>
使用Redis的理由
    memcached采用的办法是通过黑名单来隐藏列表里面的元素，从而避免对元素执行读取，更新，写入等操作，
	redis则允许用户直接添加删除元素

    使用Redis而不是memcached来解决问题，不仅可以让代码变得简单，更易懂，更易维护，而且还可以是代码的运行速度更快（因为用户不需要通过读取数据库来更新数据），除此之外，在其他许多情况下，Redis的效率和易用性也比关系型数据库要好得多。

    使用Redis构建Web应用
       1）登录cookie缓存
	   2）使用redis实现购物车
	   3）使用redis实现网页缓存
	   5）数据行缓存
	   6）网页分析，网站可以从用户的访问，交互和购买行为中收集到有价值的信息。

    数据安全与性能保障
    
    使用Redis构建支持程序
       1）使用redis记录日志
	   2）计数器和统计数据
	   3）服务的发现与配置
	
    使用Redis构建应用程序组件
       1）自动补全
       2）分布式锁
       3）计数信号量
       5）任务队列
       6）消息 拉取（PUBLISH SUBSCRIBE）
       7）使用Redis进行文件分发

    基于搜索的应用程序
       1）使用Redis进行搜索
       2）有序索引
       3）广告定向
       5）职位搜索
   
    构建简单的社交网络
       1）用户和状态
       2）主页时间线
       3）关注者列表
       5）状态消息的发布和删除
       6）流API

    降低内存占用
       1）短结构
       2）分片结构
       3）打包存储二进制位和字节
    
    扩展Redis
       1）扩展读性能
       2）扩展写性能和内存容量	
	   3）扩展复杂的查询

    Redis的Lua脚本编程
       1）使用lua重写锁和信号量
       2）移除watch/multi/exec事务
       3）使用lua对列表进行分片

</pre>

<pre>
Redis Rehash
</pre>

<pre>
Redis内存使用分析

      info memory
      命令可以查看内存使用情况。
      返回参数：
          1）used_memory：
             Redis分配器分配的内存总量，包括使用的虚拟内存（swap），
          2）used_memory_rss:
             Redis进程占据操作系统的内存，除了分配器分配的内存外，used_memory_rss还包括
             进程运行本身需要的内存，内存碎片等，但是不包括虚拟内存。

      因此,used_memory和used_memory_rss，前者是从Redis角度得到的量，后者是从操作系统角
      度得到的量。二者之所以不同，一方面是因为内存碎片和Redis进程运行需要占用内存，使得前者
      可能比后者小，另一方面虚拟内存的存在，使得前者可能比后者大。

      由于在实际应用中，Redis的数量会比较大，此时进程运行占用的内存与Redis数据量和内存碎片
      相比，都会笑的多；因此used_memory_rss和used_memory的比例，便成了衡量Redis内存碎片
      率的参数。
 
         （3）mem_fragmentation_ratio：内存碎片比率，该值是used_memory_rss / used_memory的比值。

      mem_fragmentation_ratio一般大于1，且该值越大，内存碎片比例越大。mem_fragmentation_ratio<1，说明Redis使用了虚拟内存，由于虚拟内存的媒介是磁盘，
      比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增
      加Redis节点、增加Redis服务器的内存、优化应用等

      缓冲内存：
             缓冲内存包括客户端缓冲区，复制积压缓冲区，AOF缓冲区等；其中，客户端缓冲存储
      客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲用于进行AOF重写等，
      保存最近的写入命令，

      内存碎片
             内存碎片是Redis在分配，回收物理内存过程中产生的。例如，如果对数据的更改频繁，
      而且数据之间的大小相差很大，可能导致Redis释放的空间在物理内存中并没有释放，但Redis
      又无法有效利用，这就形成了内存碎片。

             内存碎片的产生于对数据进行的操作，数据的特点等有关；此外，与使用的内存分配器
      也有关，如果内存分配器设计合理，可以尽可能的减少内存碎片的产生。

             如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片，因为
      重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内
      存单元，减小内存碎片。
</pre>

<pre>
Memcached内存分配策略
</pre>